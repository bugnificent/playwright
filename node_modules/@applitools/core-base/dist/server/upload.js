"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeUpload = void 0;
const req_1 = require("@applitools/req");
const zlib_1 = require("zlib");
const utils = __importStar(require("@applitools/utils"));
function makeUpload({ settings, logger: defaultLogger, }) {
    return async function upload({ name, resource, gzip, logger = defaultLogger }) {
        logger === null || logger === void 0 ? void 0 : logger.log(`Upload called for ${name} resource`);
        if (utils.types.isNull(resource) || utils.types.isHttpUrl(resource))
            return resource;
        else if (resource instanceof URL)
            return resource.href;
        const url = settings.uploadUrl.replace('__random__', utils.general.guid());
        const body = gzip ? (0, zlib_1.gzipSync)(resource) : resource;
        const response = await (0, req_1.req)(url, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/octet-stream',
                Date: new Date().toISOString(),
                'x-ms-blob-type': 'BlockBlob',
            },
            body,
            proxy: settings.proxy,
            retry: [
                {
                    limit: 5,
                    timeout: 500,
                    statuses: [404, 500, 502, 504],
                    codes: ['ECONNRESET', 'ECONNABORTED', 'ETIMEDOUT', 'ENOTFOUND', 'EAI_AGAIN'],
                },
                /* special retry for 503 and 429 (load)
                timing breakdown:
                Block 1: 18 retries, 60s (1m), t=60s.
                Block 2: 18 retries, 120s (2m), t=180s (3m).
                Block 3: 18 retries, 240s (4m), t=420s (7m).
                Block 4: 18 retries, 420s (7m), t=840s (14m).
                Block 5: 18 retries, 840s (14m), t=1,680s (28m).
                Block 6: 18 retries, 1,680s (28m), t=3,360s (56m).
                Total: 108 retries, 3,360s (~56 minutes).
                */
                {
                    limit: process.env.EYES_NETWORK_RETRY_LIMIT ? Number(process.env.EYES_NETWORK_RETRY_LIMIT) : 108,
                    statuses: [429, 503],
                    timeout: process.env.EYES_NETWORK_RETRY_TIMEOUT
                        ? Number(process.env.EYES_NETWORK_RETRY_TIMEOUT)
                        : [
                            ...[1, 2, 5, 6].flatMap((seconds, i) => {
                                const count = i === 2 ? 3 : 5;
                                return Array(count).fill(seconds * 1000);
                            }),
                            ...Array.from({ length: 5 }, (_, block) => [2 ** (block + 1), 2 ** (block + 2), 5 * 2 ** (block + 1), 6 * 2 ** (block + 1)].flatMap((seconds, i) => {
                                const count = i === 2 ? 3 : 5;
                                return Array(count).fill(seconds * 1000);
                            })).flat(),
                        ],
                },
            ],
            hooks: {
                beforeRetry({ response, error, attempt }) {
                    logger === null || logger === void 0 ? void 0 : logger.warn(`Upload of ${name} resource will be retried due to ${error
                        ? `an error with message "${error.message}"`
                        : `unexpected status ${response.statusText}(${response.status})`} in previous attempt (${attempt})`);
                },
            },
        });
        if (response.status !== 201) {
            throw new Error(`Upload of ${name} resource failed due to unexpected status ${response.statusText}(${response.status})`);
        }
        logger === null || logger === void 0 ? void 0 : logger.log(`Upload of ${name} resource finished successfully in location`, url);
        return url;
    };
}
exports.makeUpload = makeUpload;
